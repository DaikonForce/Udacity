{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"graph",
				"graph1〔variable〕"
			],
			[
				"gra",
				"graph1〔variable〕"
			],
			[
				"tmp",
				"tmp_edge〔variable〕"
			],
			[
				"find",
				"find_eulerian_tour〔function〕"
			],
			[
				"node",
				"node_value〔argument〕"
			],
			[
				"ins",
				"insertion_point〔variable〕"
			],
			[
				"tou",
				"tour2〔variable〕"
			],
			[
				"V",
				"ValueError〔class〕"
			],
			[
				"ex",
				"except〔keyword〕"
			],
			[
				"no",
				"node_location〔variable〕"
			],
			[
				"fin",
				"find_in_graph〔function〕"
			],
			[
				"te",
				"testValueLocation"
			],
			[
				"ne",
				"nextLargestArray"
			],
			[
				"test",
				"testArray"
			],
			[
				"testA",
				"testArrayBack"
			],
			[
				"le",
				"letterToBeat"
			],
			[
				"tm",
				"tmpArray"
			],
			[
				"tmpA",
				"tmpArrayBack"
			],
			[
				"if",
				"ifmain	if __name__ == '__main__'"
			],
			[
				"x_s",
				"x_start2"
			],
			[
				"x_",
				"x_start1"
			],
			[
				"i",
				"ifmain	if __name__ == '__main__'"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "# Eulerian Tour Ver 1\n#\n# Write a function, `create_tour` that takes as\n# input a list of nodes\n# and outputs a list of tuples representing\n# edges between nodes that have an Eulerian tour.\n#\n\n\ndef create_tour(nodes):\n    # your code here\n    # ex:   nodes = [1, 2, 3]\n    #       return [(1, 3), (1, 2), (2, 3)]\n    tour = []\n    for i in range(len(nodes)):\n        edge = (nodes[i-1], nodes[i])\n        tour.append(edge)\n    return tour\n\n#########\n\n\ndef get_degree(tour):\n    degree = {}\n    for x, y in tour:\n        degree[x] = degree.get(x, 0) + 1\n        degree[y] = degree.get(y, 0) + 1\n    return degree\n\n\ndef check_edge(t, b, nodes):\n    \"\"\"\n    t: tuple representing an edge\n    b: origin node\n    nodes: set of nodes already visited\n\n    if we can get to a new node from `b` following `t`\n    then return that node, else return None\n    \"\"\"\n    if t[0] == b:\n        if t[1] not in nodes:\n            return t[1]\n    elif t[1] == b:\n        if t[0] not in nodes:\n            return t[0]\n    return None\n\n\ndef connected_nodes(tour):\n    \"\"\"return the set of nodes reachable from\n    the first node in `tour`\"\"\"\n    a = tour[0][0]\n    nodes = set([a])\n    explore = set([a])\n    while len(explore) > 0:\n        # see what other nodes we can reach\n        b = explore.pop()\n        for t in tour:\n            node = check_edge(t, b, nodes)\n            if node is None:\n                continue\n            nodes.add(node)\n            explore.add(node)\n    return nodes\n\n\ndef is_eulerian_tour(nodes, tour):\n    # all nodes must be even degree\n    # and every node must be in graph\n    degree = get_degree(tour)\n    for node in nodes:\n        try:\n            d = degree[node]\n            if d % 2 == 1:\n                print(\"Node %s has odd degree\" % node)\n                return False\n        except KeyError:\n            print(\"Node %s was not in your tour\" % node)\n            return False\n    connected = connected_nodes(tour)\n    if len(connected) == len(nodes):\n        return True\n    else:\n        print(\"Your graph wasn't connected\")\n        return False\n\n\ndef test():\n    nodes = [20, 21, 22, 23, 24, 25]\n    tour = create_tour(nodes)\n    return is_eulerian_tour(nodes, tour)\n\nif __name__ == '__main__':\n    print(test())\n",
			"file": "PS1/create_tour.py",
			"file_size": 2334,
			"file_write_time": 131154157159348620,
			"settings":
			{
				"buffer_size": 2240,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "# Find Eulerian Tour\n#\n# Write a function that takes in a graph\n# represented as a list of tuples\n# and return a list of nodes that\n# you would follow on an Eulerian Tour\n#\n# For example, if the input graph was\n# [(1, 2), (2, 3), (3, 1)]\n# A possible Eulerian tour would be [1, 2, 3, 1]\n\n\"\"\" TODO: Need to edit for flat(?) to make it faster\n\"\"\"\n\n\ndef find_eulerian_tour(graph):\n    \"\"\"input: a graph of edges\n    output: a list of nodes that the tour follows\"\"\"\n    graph = graph[:]\n    odds = find_odd(graph)\n    if not odds:  # if there are no odd values\n        graph = reorder(graph, graph[0][0])\n        return fill_tour(graph, graph[0][0])\n    elif len(odds) == 2:  # if there are 2 even values\n        graph = reorder(graph, graph[0][0])\n        return fill_tour(graph, odds[0])\n    else:  # anything else and it won't work(?) maybe only if even number of odd values\n        print(\"Error: There is no possible tour. find_eulerian_tour function failed.\")\n        return -1\n\n\ndef find_odd(graph):\n    \"\"\"input: a graph of edges\n    output: all odd nodes in the graph\"\"\"\n    flat = sorted([item for sublist in graph[:] for item in sublist])\n    tmp_node = flat[0]\n    count = 0\n    odds = []\n    for node in flat:\n        if (node == tmp_node):\n            count += 1\n        else:\n            if count % 2 == 1:  # if odd then add it to the odd node section\n                odds.append(tmp_node)\n            count = 1\n        tmp_node = node\n    return odds\n\n\ndef graph_find(graph, node_value):\n    \"\"\"input: graph of edges, a node\n    output: the location of the node in the graph\"\"\"\n    flat = [item for sublist in graph[:] for item in sublist]\n    if node_value in flat:\n        node_location = flat.index(node_value)\n        return [node_location // 2, node_location % 2]\n    else:\n        return None\n\n\ndef reorder(graph, node_value):\n    \"\"\"reorders a graph so that all but the first values of node_value are in the back of the graph.\n    Used to make sure the graph ends on up being a tour\"\"\"\n    node_location = graph_find(graph[1:], node_value)\n    tmp_graph = []\n    while node_location:\n        x = graph.pop(node_location[0]+1)\n        tmp_graph.append(x)\n        node_location = graph_find(graph[1:], node_value)\n    return graph + tmp_graph\n\n\ndef fill_tour(graph, node_value):\n    \"\"\"Returns a tour given a graph and a start value\n    WARNING IT WILL MODIFY GRAPH\"\"\"\n    node_location = graph_find(graph, node_value)  # location in the graph\n    tour = []\n    edge = graph.pop(node_location[0])\n    tour.append(edge[node_location[1]])\n    tour.append(edge[node_location[1]-1])\n    graph_backup = []\n    while graph:\n        node_location = graph_find(graph, tour[-1])\n        try:\n            edge = graph.pop(node_location[0])\n            tour.append(edge[node_location[1]-1])\n        except TypeError:  # if there are extra edges untouched, it will return a TypeError\n            # so here, we will try to attach the extra nodes to the end of the graph\n            tmp_node = None\n            for edge in graph:\n                for node in edge:\n                    if node in tour:\n                        tmp_node = node\n            if not tmp_node:\n                print(\"Error: No valid Eulerian tour from graph!\")\n                return -1\n            tour2 = fill_tour(graph, tmp_node)  # makes a sub-tour for the leftover bits\n            insertion_point = tour.index(tour2[0])\n            # we ignore the last point of tour2 because of double counting when inserting.\n            tour = tour[:insertion_point] + tour2[:-1] + tour[insertion_point:]\n    return tour\n\n\ndef valid_tour(graph, tour):\n    \"\"\"Checks if the tour is a valid tour. Takes in a graph its corresponding tour.\"\"\"\n    i = 0\n    l = len(tour)\n    graph = graph[:]\n    if tour[0] != tour[-1]:  # check if it's a tour (starts and ends at same place)\n        return False\n    while graph:  # check if the path is a valid path and uses all possible edges\n        # for some reason using \"if edge in graph\" doesn't fucking work\n        tmp_edge = (tour[i], tour[i+1])\n        for edge in graph:\n            if tmp_edge == edge or tmp_edge[::-1] == edge:\n                graph.remove(edge)\n                edge_removed = 1\n                break\n        i += 1\n        if edge_removed == 0:\n            return False\n        edge_removed = 0\n    return True\n\n\nif __name__ == '__main__':\n    graph1 = [(0, 1), (1, 5), (1, 7), (4, 5), (4, 8), (1, 6), (3, 7), (5, 9), (2, 4), (0, 4), (2, 5), (3, 6), (8, 9)]\n    tour1 = find_eulerian_tour(graph1)\n    print(tour1)\n    print(valid_tour(graph1, tour1))\n\n    graph2 = [(1, 13), (1, 6), (6, 11), (3, 13), (8, 13), (0, 6), (8, 9), (5, 9), (2, 6), (6, 10), (7, 9), (1, 12), (4, 12), (5, 14), (0, 1),  (2, 3), (4, 11), (6, 9), (7, 14),  (10, 13)]\n    tour2 = find_eulerian_tour(graph2)\n    print(tour2)\n    print(valid_tour(graph2, tour2))\n\n    graph3 = [(8, 16), (8, 18), (16, 17), (18, 19), (3, 17), (13, 17), (5, 13), (3, 4), (0, 18), (3, 14), (11, 14), (1, 8), (1, 9), (4, 12), (2, 19), (1, 10), (7, 9), (13, 15), (6, 12), (0, 1), (2, 11), (3, 18), (5, 6), (7, 15), (8, 13), (10, 17)]\n    tour3 = find_eulerian_tour(graph3)\n    print(tour3)\n    print(valid_tour(graph3, tour3))\n",
			"file": "PS1/find_eulerian_tour.py",
			"file_size": 5350,
			"file_write_time": 131153694581756951,
			"settings":
			{
				"buffer_size": 5210,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 219.0,
		"last_filter": "install",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"package",
				"Package Control: Install Package"
			]
		],
		"width": 528.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/Documents/Workspace/Udacity/cs215",
		"/D/Documents/Workspace/Udacity/cs215/PS1"
	],
	"file_history":
	[
		"/D/Documents/Workspace/HackerRank/algorithms/andProduct/andProduct.py",
		"/D/Desktop/PowerShellColorThemes Information.txt",
		"/C/Users/mcdom/AppData/Local/Temp/Temp1_PowershellColorThemes.zip/Monokai.StorableColorTheme.ps1xml",
		"/C/Users/mcdom/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/D/Documents/Workspace/Udacity/cs215/PS1/create_tour.py",
		"/C/Users/mcdom/AppData/Roaming/Sublime Text 3/Packages/User/SublimeLinter.sublime-settings",
		"/D/Documents/Workspace/HackerRank/algorithms/fibonacciModified/fibonacciModified.py",
		"/D/Documents/Workspace/HackerRank/algorithms/biggerIsGreater/biggerIsGreater.py",
		"/D/Documents/Workspace/HackerRank/algorithms/divisibleSumPairs/divisibleSumPairs.py",
		"/D/Documents/Workspace/HackerRank/algorithms/kangaroo/kangaroo.py",
		"/D/Documents/Workspace/HackerRank/algorithms/fibonacciModified/fibonacciModified.c",
		"/D/Documents/Workspace/Shapes/README.txt",
		"/C/Users/mcdom/AppData/Roaming/Sublime Text 3/Packages/User/SublimeCodeIntel.sublime-settings",
		"/D/Documents/Workspace/HackerRank/algorithms/test/test.py",
		"/C/Users/mcdom/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"graph.",
			"in_graph",
			"find_in_graph",
			"in_graph",
			"graph.",
			"t",
			"g",
			"x",
			"y",
			"x1",
			"print(",
			"YES",
			":\n",
			"testArray"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"graph[:]",
			"graph_find",
			"graph[:]",
			"tour",
			"graph",
			"t",
			"g",
			"t1",
			"yes",
			"inArray"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "PS1/create_tour.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2240,
						"regions":
						{
						},
						"selection":
						[
							[
								489,
								489
							]
						],
						"settings":
						{
							"auto_complete": false,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 24.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "PS1/find_eulerian_tour.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5210,
						"regions":
						{
						},
						"selection":
						[
							[
								5210,
								5210
							]
						],
						"settings":
						{
							"auto_complete": false,
							"history_list_is_closing": true,
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 225.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "cs215.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
